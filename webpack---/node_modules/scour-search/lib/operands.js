'use strict';

function _typeof(obj) {
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

var cloneWithoutKeys = require('./clone_without_keys');
var assign = require('object-assign');
var each = require('../utilities/each');

/**
 * Internal: operands.
 *
 * Every operand is passed the `idx` (an `si` instance), a `condition`
 * (consisting of `{ type, key, value }`), and the `filter` function.
 *
 *     operands['$eq'] = function (idx, condition, filter) {
 *       var { key, value, type } = condition
 *
 *       // key   === 'name'
 *       // value === 'Homer'
 *       // type  === '$eq'
 *       // idx   === [si (data, indices)]
 *     }
 *
 * They're expected to return a result of keys in the same format
 * `si#getKeys()` returns.
 *
 *     { '23': 1, '45': 1, '70': 1 }
 */

var operands = {};

operands['$eq'] = function(idx, _ref) {
    var key = _ref.key;
    var value = _ref.value;

    return idx.getKeys(key, value);
};

operands['$ne'] = function(idx, _ref2, filter) {
    var key = _ref2.key;
    var value = _ref2.value;

    return filter(idx, {
        type: '$not',
        value: {
            type: '$eq',
            key: key,
            value: value
        }
    });
};

operands['$or'] = unary(function(idx, _ref3, filter) {
    var value = _ref3.value;

    var result = {};

    for (var i = 0, len = value.length; i < len; i++) {
        var subcon = value[i];
        var keys = filter(idx, subcon);
        if (!keys) return;
        assign(result, keys);
    }

    return result;
});

operands['$nor'] = unary(function(idx, _ref4, filter) {
    var value = _ref4.value;

    return filter(idx, {
        type: '$not',
        value: {
            type: '$or',
            value: value
        }
    });
});

operands['$and'] = unary(function(idx, _ref5, filter) {
    var value = _ref5.value;

    var result = {};

    var _loop = function _loop() {
        var subcon = value[i];
        var keys = filter(idx, subcon);
        if (!keys) return {
            v: undefined
        };
        if (i === 0) assign(result, keys);
        else {
            each(result, function(_, key) {
                if (!keys[key]) delete result[key];
            });
        }
    };

    for (var i = 0, len = value.length; i < len; i++) {
        var _ret = _loop();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }

    return result;
});

operands['$in'] = function(idx, _ref6, filter) {
    var key = _ref6.key;
    var value = _ref6.value;

    return filter(idx, {
        type: '$or',
        value: value.map(function(subvalue) {
            return {
                type: '$eq',
                key: key,
                value: subvalue
            };
        })
    });
};

operands['$not'] = unary(function(idx, _ref7, filter) {
    var value = _ref7.value;

    var subcon = value;
    var result = filter(idx, subcon);

    if (result) return cloneWithoutKeys(idx.data, result);
});

operands['$nin'] = function(idx, _ref8, filter) {
    var key = _ref8.key;
    var value = _ref8.value;

    return filter(idx, {
        type: '$not',
        value: {
            type: '$in',
            key: key,
            value: value
        }
    });
};

module.exports = operands;

function unary(fn) {
    fn.unary = true;
    return fn;
}