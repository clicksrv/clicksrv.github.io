function _extends() {
    _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

import React, {
    forwardRef,
    useCallback,
    useImperativeHandle,
    useRef
} from "react";
import {
    getFilesFromDragEvent
} from "html-dir-content";
import {
    useUploadyContext,
    markAsUploadOptionsComponent
} from "@rpldy/shared-ui";
const UploadDropZone = /*#__PURE__*/ forwardRef((_ref, ref) => {
    let {
        className,
        id,
        children,
        onDragOverClassName,
        dropHandler,
        htmlDirContentParams,
        extraProps,
        ...uploadOptions
    } = _ref;
    const {
        upload
    } = useUploadyContext();
    const containerRef = useRef(null);
    const dragLeaveTrackerRef = useRef(false);
    useImperativeHandle(ref, () => containerRef.current, []); //using ref so upload can stay memoized

    const uploadOptionsRef = useRef();
    uploadOptionsRef.current = uploadOptions;
    const handleEnd = useCallback(() => {
        dragLeaveTrackerRef.current = false;

        if (containerRef.current && onDragOverClassName) {
            containerRef.current.classList.remove(onDragOverClassName);
        }
    }, [onDragOverClassName, containerRef]);
    const dropFileHandler = useCallback(e => {
        return dropHandler ? Promise.resolve(dropHandler(e)) : getFilesFromDragEvent(e, htmlDirContentParams || {});
    }, [dropHandler, htmlDirContentParams]);
    const handleDropUpload = useCallback(e => {
        dropFileHandler(e).then(files => {
            upload(files, uploadOptionsRef.current);
        });
    }, [upload, dropFileHandler, uploadOptionsRef]);
    const onDragEnter = useCallback(e => {
        dragLeaveTrackerRef.current = !dragLeaveTrackerRef.current && e.target === containerRef.current;

        if (containerRef.current && onDragOverClassName) {
            containerRef.current.classList.add(onDragOverClassName);
        }
    }, [onDragOverClassName, containerRef]);
    const onDragOver = useCallback(e => {
        //must have drag over event handler with preventDefault for drop to work
        e.preventDefault();
    }, []);
    const onDrop = useCallback(e => {
        e.preventDefault();
        e.persist();
        handleEnd();
        handleDropUpload(e);
    }, [handleEnd, handleDropUpload]);
    const onDragLeave = useCallback(e => {
        if (dragLeaveTrackerRef.current && e.target === containerRef.current) {
            handleEnd();
        }
    }, [handleEnd, containerRef]);
    const onDragEnd = useCallback(e => {
        e.preventDefault();
        e.stopPropagation();
        handleEnd();
    }, [handleEnd]);
    return /*#__PURE__*/ React.createElement("div", _extends({
        id: id,
        className: className,
        ref: containerRef,
        onDragOver: onDragOver,
        onDragEnter: onDragEnter,
        onDrop: onDrop,
        onDragLeave: onDragLeave,
        onDragEnd: onDragEnd
    }, extraProps), children);
});
markAsUploadOptionsComponent(UploadDropZone);
export default UploadDropZone;