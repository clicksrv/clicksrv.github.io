var isArray = function(e) {
        return Array.isArray(e)
    },
    isObject = function(e) {
        return "Object" === Object.prototype.toString.call(e).slice(8, -1)
    },
    validate = function(e) {
        if (void 0 === e) throw new Error("This method requires one parameter");
        if (!isArray(e) && !isObject(e)) throw new TypeError("This method only accepts arrays and objects")
    },
    isRef = function(e) {
        return isObject(e) && e.hasOwnProperty("$ref") && 1 === Object.keys(e).length && !!e.$ref && "$" === e.$ref.charAt(0)
    },
    encycle = function(arg) {
        validate(arg);
        var recurs = function(value) {
            return isArray(value) || isObject(value) ? isArray(value) ? value.map(function(elem, i) {
                return isRef(elem) ? (value[i] = eval("arg" + elem.$ref.slice(1)), value) : recurs(elem)
            }) : Object.keys(value).reduce(function(accum, key) {
                return accum[key] = isRef(value[key]) ? eval("arg" + value[key].$ref.slice(1)) : recurs(value[key]), accum
            }, value) : value
        };
        return recurs(arg)
    },
    findRef = function(e, r) {
        return Object.keys(r).find(function(c) {
            return r[c] === e
        })
    },
    decycle = function(e) {
        validate(e);
        var r = {},
            c = function(e, t) {
                void 0 === t && (t = "$");
                var n = findRef(e, r);
                return n ? {
                    $ref: n
                } : isArray(e) || isObject(e) ? (r[t] = e, isArray(e) ? e.map(function(e, r) {
                    return c(e, t + "[" + r + "]")
                }) : Object.keys(e).reduce(function(r, n) {
                    return r[n] = c(e[n], t + "." + n), r
                }, {})) : e
            };
        return c(e)
    };
exports.encycle = encycle, exports.decycle = decycle;
//# sourceMappingURL=index.js.map