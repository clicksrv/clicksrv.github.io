"use strict";
var _logger = _interopRequireDefault(require("./logger"));
Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports["default"] = void 0;

function _interopRequireDefault(a) {
    return a && a.__esModule ? a : {
        default: a
    }
}

function _classCallCheck(a, b) {
    if (!(a instanceof b)) throw new TypeError("Cannot call a class as a function")
}

function _defineProperties(a, b) {
    for (var c, d = 0; d < b.length; d++) c = b[d], c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(a, c.key, c)
}

function _createClass(a, b, c) {
    return b && _defineProperties(a.prototype, b), c && _defineProperties(a, c), a
}
var ContentScript = function() {
        function a(b, c, d) {
            var e = this;
            if (_classCallCheck(this, a), this.store = b, this.browser = c, this.settings = d, this.scriptId = Math.random().toString(36).substr(2, 9), this.connection = null, this.receivedMutations = [], this.receivedActions = [], this.initialized = !1, this.pendingMutations = [], this.pendingActions = [], this.connection = c.connectToBackground("".concat(this.settings.connectionName, "_").concat(this.scriptId)), this.connection.onMessage.addListener(function(a) {
                    e.onMessage(a)
                }), _logger["default"].verbose("Listening for mutations"), this.store.subscribe(function(a) {
                    e.hookMutation(a)
                }), !0 == this.settings.syncActions) try {
                _logger["default"].verbose("Listening for actions"), this.store.subscribeAction(function(a) {
                    a.payload instanceof Event && (a.payload = null), e.hookAction(a)
                })
            } catch (a) {
                _logger["default"].info("Can't sync actions because isn't available in your Vuex version, use Vuex v2.5.0 or later for this feature")
            }
        }
        return _createClass(a, [{
            key: "onMessage",
            value: function onMessage(a) {
                if (_logger["default"].verbose("Received message from background"), !!a.type) switch (a.type) {
                    case "@@STORE_SYNC_STATE":
                        {
                            _logger["default"].info("Received store initial state"),
                            this.store.commit("vweReplaceState", a.data),
                            this.initialized = !0,
                            this.processPendingMutations();
                            break
                        }
                    case "@@STORE_SYNC_MUTATION":
                        {
                            if (_logger["default"].debug("Received mutation ".concat(a.data.type)), !this.initialized) {
                                _logger["default"].info("Received mutation (".concat(a.data.type, ") but the store isn't initilized yet"));
                                break
                            }
                            this.receivedMutations.push(a.data),
                            this.store.commit(a.data.type, a.data.payload);
                            break
                        }
                    case "@@STORE_SYNC_ACTION":
                        {
                            if (_logger["default"].debug("Received action ".concat(a.data.type)), !this.initialized) {
                                _logger["default"].info("Received action (".concat(a.data.type, ") but the store isn't initilized yet"));
                                break
                            }
                            this.receivedActions.push(a.data),
                            this.store.dispatch(a.data);
                            break
                        }
                    default:
                }
            }
        }, {
            key: "hookMutation",
            value: function hookMutation(a) {
                if (_logger["default"].debug("Hooked mutation (".concat(a.type, ")")), "vweReplaceState" === a.type) return void _logger["default"].debug("vweReplaceState mutation don't need send to other contexts");
                if (0 < this.settings.ignoredMutations.length && this.settings.ignoredMutations.includes(a.type)) return void _logger["default"].info("Mutation (".concat(a.type, ") are on ignored mutations list, skiping..."));
                if (!this.initialized) return _logger["default"].info("Hooked mutation (".concat(a.type, ") before initialization, enqued on pending mutations")), this.pendingMutations.push(a);
                if (!this.receivedMutations.length) return this.sendMutation(a);
                for (var b = this.receivedMutations.length - 1; 0 <= b; b--) this.receivedMutations[b].type == a.type && this.receivedMutations[b].payload == a.payload ? (_logger["default"].verbose("Mutation ".concat(this.receivedMutations[b].type, " it's received mutation, don't send to background again")), this.receivedMutations.splice(b, 1)) : 0 == b && this.sendMutation(a)
            }
        }, {
            key: "hookAction",
            value: function hookAction(a) {
                if (_logger["default"].debug("Hooked action (".concat(a.type, ")")), 0 < this.settings.ignoredActions.length && this.settings.ignoredActions.includes(a.type)) return void _logger["default"].info("Action (".concat(a.type, ") are on ignored action list, skiping..."));
                if (!this.initialized) return _logger["default"].info("Hooked action (".concat(a.type, ") before initialization, enqued on pending actions")), this.pendingActions.push(a);
                if (!this.receivedActions.length) return this.sendAction(a);
                for (var b = this.receivedActions.length - 1; 0 <= b; b--) this.receivedActions[b].type == a.type && this.receivedActions[b].payload == a.payload ? (_logger["default"].verbose("Action ".concat(this.receivedActions[b].type, " it's received action, don't send to background again")), this.receivedActions.splice(b, 1)) : 0 == b && this.sendAction(a)
            }
        }, {
            key: "sendMutation",
            value: function sendMutation(a) {
                _logger["default"].debug("Sending mutation (".concat(a.type, ") to background script")), this.connection.postMessage({
                    type: "@@STORE_SYNC_MUTATION",
                    data: a
                })
            }
        }, {
            key: "sendAction",
            value: function sendAction(a) {
                _logger["default"].debug("Sending action (".concat(a.type, ") to background script")), this.connection.postMessage({
                    type: "@@STORE_SYNC_ACTION",
                    data: a
                })
            }
        }, {
            key: "processPendingMutations",
            value: function processPendingMutations() {
                if (_logger["default"].debug("Processing pending mutations list..."), !this.pendingMutations.length) return void _logger["default"].info("The pending mutations list are empty");
                for (var a = 0; a < this.pendingMutations.length; a++) _logger["default"].verbose("Processing pending mutation (".concat(this.pendingMutations[a].type, ") with payload: ").concat(this.pendingMutations[a].payload)), this.store.commit(this.pendingMutations[a].type, this.pendingMutations[a].payload), this.pendingMutations.splice(a, 1)
            }
        }, {
            key: "processPendingActions",
            value: function processPendingActions() {
                if (_logger["default"].debug("Processing pending actions list..."), !this.pendingActions.length) return void _logger["default"].info("The pending actions list are empty");
                for (var a = 0; a < this.pendingActions.length; a++) _logger["default"].verbose("Processing pending action (".concat(this.pendingActions[a].type, ") with payload: ").concat(this.pendingActions[a].payload)), this.store.dispatch(this.pendingActions[a].type, this.pendingActions[a].payload), this.pendingActions.splice(a, 1)
            }
        }]), a
    }(),
    _default = ContentScript;
exports["default"] = _default;