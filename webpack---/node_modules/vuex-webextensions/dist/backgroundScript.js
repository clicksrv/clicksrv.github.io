"use strict";
Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports["default"] = void 0;
var _logger = _interopRequireDefault(require("./logger")),
    _utils = require("./utils");

function _interopRequireDefault(a) {
    return a && a.__esModule ? a : {
        default: a
    }
}

function ownKeys(a, b) {
    var c = Object.keys(a);
    if (Object.getOwnPropertySymbols) {
        var d = Object.getOwnPropertySymbols(a);
        b && (d = d.filter(function(b) {
            return Object.getOwnPropertyDescriptor(a, b).enumerable
        })), c.push.apply(c, d)
    }
    return c
}

function _objectSpread(a) {
    for (var b, c = 1; c < arguments.length; c++) b = null == arguments[c] ? {} : arguments[c], c % 2 ? ownKeys(b, !0).forEach(function(c) {
        _defineProperty(a, c, b[c])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(b)) : ownKeys(b).forEach(function(c) {
        Object.defineProperty(a, c, Object.getOwnPropertyDescriptor(b, c))
    });
    return a
}

function _defineProperty(a, b, c) {
    return b in a ? Object.defineProperty(a, b, {
        value: c,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : a[b] = c, a
}

function _classCallCheck(a, b) {
    if (!(a instanceof b)) throw new TypeError("Cannot call a class as a function")
}

function _defineProperties(a, b) {
    for (var c, d = 0; d < b.length; d++) c = b[d], c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(a, c.key, c)
}

function _createClass(a, b, c) {
    return b && _defineProperties(a.prototype, b), c && _defineProperties(a, c), a
}
var BackgroundScript = function() {
        function a(b, c, d) {
            var e = this;
            if (_classCallCheck(this, a), this.store = b, this.browser = c, this.settings = d, this.connections = [], this.settings.persistentStates.length && (_logger["default"].info("Persistent states detected on config, reading from localstorage..."), this.browser.getPersistentStates().then(function(a) {
                    if (null === a) _logger["default"].debug("No data found on localstorage for persistent states");
                    else if (_logger["default"].verbose("Saved persistent states found on localstorage"), e.store.commit("vweReplaceState", _objectSpread({}, e.store.state, {}, (0, _utils.filterObject)(a, e.settings.persistentStates))), 0 < e.connections.length) {
                        _logger["default"].info("Sending initial state to other contexts...");
                        for (var b = e.connections.length - 1; 0 <= b; b--) e.syncCurrentState(e.connections[b])
                    }
                })), this.store.subscribe(function(a) {
                    if (_logger["default"].debug("Hooked mutation (".concat(a.type, ")")), 0 < e.settings.ignoredMutations.length && e.settings.ignoredMutations.includes(a.type)) return void _logger["default"].info("Mutation (".concat(a.type, ") are on ignored mutations list, skiping..."));
                    for (var b = e.connections.length - 1; 0 <= b; b--) {
                        e.connections[b].receivedMutations.length || e.sendMutation(e.connections[b], a);
                        for (var d = e.connections[b].receivedMutations.length - 1; 0 <= d; d--) e.connections[b].receivedMutations[d].type == a.type && e.connections[b].receivedMutations[d].payload == a.payload ? e.connections[b].receivedMutations.splice(d, 1) : 0 == b && e.sendMutation(e.connections[b], a)
                    }
                    c.savePersistentStates((0, _utils.filterObject)(e.store.state, e.settings.persistentStates))
                }), !0 == this.settings.syncActions) try {
                _logger["default"].verbose("Listening for actions"), this.store.subscribeAction(function(a) {
                    if (_logger["default"].debug("Hooked action (".concat(a.type, ")")), 0 < e.settings.ignoredActions.length && e.settings.ignoredActions.includes(a.type)) return void _logger["default"].info("Action (".concat(a.type, ") are on ignored actions list, skiping..."));
                    for (var b = e.connections.length - 1; 0 <= b; b--) {
                        e.connections[b].receivedActions.length || e.sendAction(e.connections[b], a);
                        for (var c = e.connections[b].receivedActions.length - 1; 0 <= c; c--) e.connections[b].receivedActions[c].type == a.type ? e.connections[b].receivedActions.splice(c, 1) : 0 == b && e.sendAction(e.connections[b], a)
                    }
                })
            } catch (a) {
                _logger["default"].info("Can't sync actions because isn't available in your Vuex version, use Vuex v2.5.0 or later for this feature")
            }
            c.handleConnection(function(a) {
                e.onConnection(a)
            })
        }
        return _createClass(a, [{
            key: "onConnection",
            value: function onConnection(a) {
                var b = this;
                a.onDisconnect.addListener(function(a) {
                    b.onDisconnect(a)
                }), a.receivedMutations = [], a.receivedActions = [], a.onMessage.addListener(function(c) {
                    b.onMessage(a, c)
                }), this.connections.push(a), this.syncCurrentState(a)
            }
        }, {
            key: "onDisconnect",
            value: function onDisconnect(a) {
                for (var b = this.connections.length - 1; 0 <= b; b--) this.connections[b].name === a.name && this.connections.splice(b, 1)
            }
        }, {
            key: "onMessage",
            value: function onMessage(a, b) {
                if (b.type) switch (b.type) {
                    case "@@STORE_SYNC_MUTATION":
                        {
                            a.receivedMutations.push(b.data),
                            this.store.commit(b.data.type, b.data.payload);
                            break
                        }
                    case "@@STORE_SYNC_ACTION":
                        {
                            a.receivedActions.push(b.data),
                            this.store.dispatch(b.data.type, b.data.payload);
                            break
                        }
                    default:
                }
            }
        }, {
            key: "syncCurrentState",
            value: function syncCurrentState(a) {
                try {
                    a.postMessage({
                        type: "@@STORE_SYNC_STATE",
                        data: this.store.state
                    })
                } catch (a) {
                    _logger["default"].error("Initial state not sent: ".concat(a))
                }
            }
        }, {
            key: "sendMutation",
            value: function sendMutation(a, b) {
                _logger["default"].verbose("Sending mutation (".concat(b.type, ") to connection: ").concat(a.name));
                try {
                    a.postMessage({
                        type: "@@STORE_SYNC_MUTATION",
                        data: b
                    })
                } catch (a) {
                    _logger["default"].error("Mutation not sent: ".concat(a))
                }
            }
        }, {
            key: "sendAction",
            value: function sendAction(a, b) {
                _logger["default"].verbose("Sending action (".concat(b.type, ") to connection: ").concat(a.name));
                try {
                    a.postMessage({
                        type: "@@STORE_SYNC_ACTION",
                        data: b
                    })
                } catch (a) {
                    _logger["default"].error("Action not sent: ".concat(a))
                }
            }
        }]), a
    }(),
    _default = BackgroundScript;
exports["default"] = _default;